; #BlitzBasic2 - Amiga Midi Get File To RAM - by Sebastian I. Hartmann 6-2025
; based on code by Claude Heiland-Allen, mathr.co.uk/amiga/midi-file-transfer/
; Written on A1200 with Blizzard 1230 IV 030
; License: CC Attribution - Non commercial
;
;------------------ it is a beautiful day, and then you die ------------------
;
; this requires a python 3.0 script that i designed using chatgpt5+.
; it should have been delivered with the archive. you will need a midi-
; out cable from your "computer" to the midi-in of your Amiga Midi Interface
;
; V0.3/9-25 this version shows how many chunks have been received, so you have
; a better estimate of what to do while waiting.
;
;------------------- how to use: ---------------------------------------------
;
; set up your Midi cable connection: only pc-out --> amiga-in is needed
; 1. run Amiga Midi Get File on your amiga and see that it expects data
; 2. drag and drop your payload onto the python script on the PC, select Midi device
; 3. data will be transmitted. be very patient. do not do anything on your Amiga!
; 4. when transfer is complete, copy File from AMIGA ram to desired location.
; 5. make sure that the file received is intact (always send lzx, lha or zip files!)
; 6. both receiver and sender should be V0.3, old versions are incompatible
; 7. WARNING: Files in RAM will be overwritten without asking! (no problem)
;
;-----------------------------------------------------------------------------
;
; if you reenable any debug functions, make sure to noticeably increase wait times
; on the python script. also do so, if you run this bb2 with debugger=ON
;
; i don`t fashioncode, i am just old-school, lazy and stubborn
; if you don`t like it - don`t use it.
; If you use it, do so at your own risk! Files in ramdisk will be overwritten
; without asking! If you do unexpected stuff, unexpected stuff will happen!
;
; DISCLAIMER:
; !!!----- this is experimental software, use at your own risk! -----!!!
;
; This has only been tested with files <10 MB ... nobody would want to send
; such large files anyways, because it would take forever. Do not try it!
;
;=============================================================================

;Setup Screen
      WBStartup
      WbToScreen 0

      winxdim=600 ; window total x size
      winydim=190 ; window total y size
      winxloc=10  ; window x location
      winyloc=10  ; window y location

      winwith = winxdim-4 ; window x insides minus border
      winhigh = winydim-4 ; window y insides minus border

      Window 1,winxloc,winyloc,winxdim,winydim,$1004,"MIDI GET FILE V0.3 (c) Sebastian I. Hartmann 9-2025 - LMB TO EXIT ",0,1
      Use Window 1

      ;Open Midi Port : variable.l = Openserial ("device name", #unit, #Baud, BIN_int_IO-Serflags )
      ; Openserial : serial.device
      ; Device Number: 0 in this case is Port 0, Channel 1
      ; Baud: 31250 is the Midi standard, fixed baud rate.
      ; #serf_xdisable=128    ;0100 0000 ;disable xon/xoff
      ; #serf_eofmode=64      ;0010 0000 ;enable eof checking
      ; #serf_shared=32       ;0001 0000 ;set it if you don`t need exclusive use of the port
      ; #serf_rad_boogie=16   ;0000 1000 ;high speed mode
      ; #serf_queuedbrk=8     ;0000 0100 ;if set, a break command waits for buffer empty
      ; #serf_parity_odd=2    ;0000 0010 ;select odd parity (even if not set)
      ; #serf_praity_on=1     ;0000 0001 ;enable parity checking

      ser.l = OpenSerial("serial.device", 0, 31250, 144) ;see spec above
      SetSerialBuffer 0, 100000  ;Unit Number, Buffer read ahead bytes, for computational stream read pauses, RAM dependent

;-------- variables ----------------

      Dim fnam(64)            ;contents of the filename buffer x 2 because we store hex 2-digit bytes

      Dim chunxpected(32)     ;number of bytes for amounts of chunks to be expected, 16+safety ;

      fnamlen=0               ;initial filename length
      fnpnt=1                 ;filenamepointer
      chunxlen=0              ;initial chunkamount lenght
      chunpnt=1               ;chunkamountpointer
      x=1  ; screen cursor x  ;debug
      y=4  ; screen cursor y  ;debug
      default_y = y           ;debug
      default_x = x
      xmax = 63
      ymax = 24
      termearly = 1
      ytop = 9+(4*8)
      curstop = 4*8

      WLocate default_x,0

      ResetTimer

;-------------------------------------------------------------------------------------------
;----------------- Welcome Message     -----------------------------------------------------


      Print "Click LMB at any time to cancel. Now listening on MIDI Port 0, Channel 1:" : NPrint""
      Print "--==** Make sure there is enough free RAM: no filesize checking! **==--" : NPrint""
      Print "This window cannot be moved. Clicking will terminate. LISTENING... . . " : NPrint""

;---------------- get filename, and print it  ----------------------------------------------
;-------------------------------------------------------------------------------------------
;---------------- first get header bytes ---------------------------------------------------

      ;Goto directdump           ;debug
      a$ = "00"                 ;empty swapbuffers

.loop_header

      r = 0 : t = 0
      b$ = a$                   ;swap/scroll the two observed buffer bytes until the header matches

      c.w = ReadSerial(0)       ;get next word
      ;Gosub directprint         ;debug

      If c.w <>-1 Then a$=Right$(Hex$(c.w),2)  ;hex translation of incoming bytes to stringbuffer

      If a$ =  "F0" Then r=1
      If b$ =  "EA" Then t=1
      If t + r = 2 Then Goto header_ok

      If Joyb(0)=1 Goto thatsit
      If Joyb(0)<>1 Goto loop_header

;-------------------------------------------------------------------------------------------

.header_ok

;-------------------------------------------------------------------------------------------

      NPrint "Transmission in progress. Leave Amiga be. Don`t insert/remove floppy!"
      NPrint "         Suggestion: have a tea  or..  maybe two..." : NPrint""


    ;Goto thatsit                ;early debug out

;-------------- valid stream identified, receive filename ----------------------------------
;-------------------------------------------------------------------------------------------

    a = 0

.loop_fnam_build
      ;get the filename max 32 chars terminated with F0(240) EA(234)

      c.w = ReadSerial(0) ;get next word

      t=0 : r=0
      b = a          ;buffer scroll/swap

      If c.w >-1 Then char.b = c.w : fnam(fpnt)= char.b : a=fnam(fpnt): fpnt=fpnt+1
      If fpnt > 31 Goto fnam_error

      If a+256 = 234 Then t=1
      If b+256 = 240 Then r=1
      If t + r = 2 Then Goto fnam_done

      If Joyb(0)=1 Goto thatsit
      If Joyb(0)<>1 Goto loop_fnam_build

.fnam_done
      Print "Incoming file:"
      For e = 0 To fpnt-3: Print Chr$(fnam(e)) : Next e   ;Print recieved filename
      NPrint ""

    ;Goto thatsit     ;early out debug


;---------------- Reception of amount of chunks ------------------------------------

; we will be receiving 16 bytes of which each represents a number between 0 and 9
; this number will be assembled into one large integer number and will reflect
; how many chunks +1 are expected

      a = 0

.loop_chunksz_build
      ;get the chunk size 16 chars(digits 0-9) terminated with F0(240) EA(234)

      c.w = ReadSerial(0) ;get next word

      t=0 : r=0
      b = a          ;buffer scroll/swap

      If c.w >-1 Then char.b = c.w : chunxpected(chunpnt)= char.b : a=chunxpected(chunpnt): chunpnt=chunpnt+1
      ;no error checking, chuncks length is always 16 digits

      If a+256 = 234 Then t=1
      If b+256 = 240 Then r=1
      If t + r = 2 Then Goto chunkz_done

      If Joyb(0)=1 Goto thatsit
      If Joyb(0)<>1 Goto loop_chunksz_build

.chunkz_done
      ;Print "Incoming amount of chunks:"               ;debug

      chrchunk$=""
      numchunks.l=0

      For e = 2 To chunpnt-3 : chrchunk$ = chrchunk$+Chr$(chunxpected(e)) : Next e    ;translate but discard sysex bytes
      numchunks.l = Val(chrchunk$)

      ;NPrint numchunks.l                               ;debug Print recieved expected number of chunks
      ;NPrint chrchunk$                                 ;debug
      ;Goto thatsit                                     ;early out debug

;-------------- header, filename and expected chunks done, now datastream --------------------
;---------------------------------------------------------------------------------------------

      numchunks.l = numchunks.l -1 ; a little cheat

      chunksrec.l = 0

;Skip the next byte of the datastream (F0 sysex data)

.skiponebyte
      c.w = ReadSerial(0)
      If c.w = -1 Then Goto skiponebyte

;---------------------------------------------------------------------------------------------
;------------------------------ get main body of data ----------------------------------------

;Open File in RAM for Data Output - will be overwritten without asking.

      fileoutname$="" : For e=0 To fpnt-3 : fileoutname$ = fileoutname$ + (Chr$(fnam(e))) : Next e
      out.l = WriteFile(1, "ram:"+(fileoutname$))

;---------------------------------------------------------------------------------------------

.startim
      ResetTimer

      termearly = 0
      baccept = 0
      timeout = 3000
      tt=0

.loop_datachunk  ;----------------------------------------------------------------------------

      c.w = ReadSerial(0)  ;get next word

;unless the word received is -1 : make a byte out of it, write to disk and screen and loop
;The data stream will, when finished, just end. No terminator will be checked.

      recon=0

      If c.w >-1 Then recon = 1 : tt = 0 : baccept = baccept +1   ;: Print Right$(Hex$(c.w),2)+" " : x=x+3 ; debug

      If recon = 1 Then char.b = c.w : WriteMem 1,&char.b,1

      If c.w < 0 Then tt = tt +1 : If tt > timeout Goto file_recieved

      If baccept = 242 Then baccept = 0 : Gosub byteskips

      ;If x > 48*3 Then NPrint "" : x=0 : y=y+1      ;debug
      ;If y>xmax Then y=default_y : WCls : WLocate x,y ;debug

      If Joyb(0)=1 Goto thatsit
      If Joyb(0)<>1 Goto loop_datachunk



;-------------------------------- close the file --------------------------------------------

.thatsit

      If chunksrec.l < numchunks.l Then termearly = 1
      If termearly = 1 Then Goto terminatedpre

.entim ;------------------------- calculate and display elapsed time ------------------------
      entime.l = Ticks
      totalsecs$ = Str$((entime.l/50)+1)
      mintime.l = ((entime.l/50)/60)
      enminit$ = Str$(mintime.l)

      If mintime.l < 1 Then enminit$="<1"
      extd$=""
      If mintime.l > 1 Then extd$="s"

      NPrint ""
      NPrint "Transmission time was " + totalsecs$ + " seconds. (about "+enminit$+" minute"+extd$+")"

.nothing ;-------------------- close file and serial port -----------------------------------------
      NPrint "Finishing up."
      ;   For bb = 3 To fpnt : hh =d confbuf(bb) : Print Right$(Hex$(hh),2)+" " : Next bb ;debug

      CloseFile (1)
      VWait 10
      CloseSerial 0
      VWait 10

      NPrint ""
      If termearly=0 Then NPrint "<<< Click LMB to close and exit - File stays in RAM. >>>"
      If termearly=1 Then NPrint "<<< Click LMB to close and exit - Leftovers in RAM are garbage.>>>"

.waitexit
      If Joyb(0)<>1 Goto waitexit

.catch22
      VWait
      If Joyb(0)<>0 Then Goto catch22

End  ;-------------------- end of main program, exit to workbench ----------------------------------------
;---------------------------------------------------------------------------------------------------------
;=========================================================================================================
;=========================================================================================================

.terminatedpre
      NPrint ""
      NPrint "   --- Transmission was terminated prematurely. --- " : NPrint ""
      termearly=1
      Goto nothing

;----------------------------------------------------------------------------------

.byteskips ;instead of filtering the sysex bytes, we just skip them

      byteskipcount=1

.byteskiploop

      c.w = ReadSerial(0)

      If c.w = -1 Then Goto byteskiploop

        byteskipcount = byteskipcount - 1

      If byteskipcount > 0 Then Goto byteskiploop

          chunksrec.l = chunksrec.l +1

          WLocate default_x,60 : Print "Chunks expected ",(numchunks.l+1)," / received:",chunksrec.l ;lil cheat

     Return


;-------------------------------------------------------------------------------------

.file_recieved

      If chunksrec.l < numchunks.l Then Goto terminatedpre

      x=0 : y=default_y

      WBox 4,ytop+2,winwith,winhigh,0
      WLocate default_x,ytop
      NPrint "********************************************************"
      NPrint ""
      NPrint " File RAM:"+fileoutname$+" complete."
      NPrint ""
      NPrint "      >>> Make sure to check file integrity! <<<"
      NPrint "             There is no error correction!"
      NPrint ""
      NPrint "********************************************************"
      Goto thatsit

;----------------------------------------------------------------------------------

.fnam_error
      x=0 : y=default_y
      WBox 4,ytop+2,winwith,winhigh,0
      WLocate default_x,ytop
      NPrint "Filename did not terminate. Not cool. Exiting."
      Goto thatsit

;------------------------------ no more guessing -----------------------------------

.directdump

.loop_directdump

      c.w = ReadSerial(0)  ;get next word

;unless the word received is -1 : make a byte out of it, write to disk and screen and loop

      If c.w >-1 Print Right$(Hex$(c.w),2)+" " : Gosub movectransm

      If Joyb(0)<>1 Goto loop_directdump

      Goto thatsit

;-----------------------------  i`ve got all the answers -----------------------------

.directprint

      If c.w >-1 Print Right$(Hex$(c.w),2)+" ": Gosub movecursor

      Return

;---------------------------- cursor move + reset -----------------------------------

.movecursor

     x = x + 1
     If x > xmax Then x = default_x : NPrint "" : y=y+1 : If y>ymax Then y=default_y
     WBox 4,ytop,winwith,winhigh,0 : WLocate x,ytop

     Return


;---------------------------- cursor move + reset -----------------------------------

.movectransm

     x = x + 1
     If x > xmax Then x = default_x : NPrint "" : y=y+1 : If y>ymax Then y=default_y+2
     WBox 4,ytop+18,winwith,winhigh,0 : WLocate x,ytop+7

     Return


;==================================================================================
;#EOF
